import { ICategoricalStatistics, IStatistics } from '../internal';
import AEventDispatcher from '../internal/AEventDispatcher';
import { Column, ICategoricalColumn, IColumnDesc, IDataRow, IGroup, INumberColumn, IOrderedGroup } from '../model';
import Ranking from '../model/Ranking';
import { IExportOptions } from './utils';
export { IExportOptions } from './utils';
export interface IStatsBuilder {
    stats(col: INumberColumn): Promise<IStatistics> | IStatistics;
    hist(col: ICategoricalColumn): Promise<ICategoricalStatistics> | ICategoricalStatistics;
}
export interface IDataProviderOptions {
    columnTypes: {
        [columnType: string]: typeof Column;
    };
    multiSelection: boolean;
}
export interface IDataProvider extends AEventDispatcher {
    readonly columnTypes: {
        [columnType: string]: typeof Column;
    };
    getTotalNumberOfRows(): number;
    takeSnapshot(col: Column): void;
    selectAllOf(ranking: Ranking): void;
    getSelection(): number[];
    setSelection(dataIndices: number[]): void;
    toggleSelection(i: number, additional?: boolean): boolean;
    isSelected(i: number): boolean;
    removeRanking(ranking: Ranking): void;
    ensureOneRanking(): void;
    find(id: string): Column | null;
    clone(col: Column): Column;
    create(desc: IColumnDesc): Column | null;
    toDescRef(desc: IColumnDesc): any;
    fromDescRef(ref: any): IColumnDesc;
    mappingSample(col: Column): Promise<number[]> | number[];
    searchAndJump(search: string | RegExp, col: Column): void;
    getRankings(): Ranking[];
    getLastRanking(): Ranking;
    getColumns(): IColumnDesc[];
    isAggregated(ranking: Ranking, group: IGroup): boolean;
    aggregateAllOf(ranking: Ranking, aggregateAll: boolean): void;
}
declare abstract class ADataProvider extends AEventDispatcher implements IDataProvider {
    static readonly EVENT_SELECTION_CHANGED: string;
    static readonly EVENT_ADD_COLUMN: string;
    static readonly EVENT_REMOVE_COLUMN: string;
    static readonly EVENT_ADD_RANKING: string;
    static readonly EVENT_REMOVE_RANKING: string;
    static readonly EVENT_DIRTY: string;
    static readonly EVENT_DIRTY_HEADER: string;
    static readonly EVENT_DIRTY_VALUES: string;
    static readonly EVENT_ORDER_CHANGED: string;
    static readonly EVENT_ADD_DESC: string;
    static readonly EVENT_CLEAR_DESC: string;
    static readonly EVENT_JUMP_TO_NEAREST: string;
    static readonly EVENT_GROUP_AGGREGATION_CHANGED: string;
    private rankings;
    private readonly selection;
    private aggregations;
    private uid;
    readonly columnTypes: {
        [columnType: string]: typeof Column;
    };
    protected readonly multiSelections: boolean;
    constructor(options?: Partial<IDataProviderOptions>);
    protected createEventList(): string[];
    abstract getTotalNumberOfRows(): number;
    abstract getColumns(): IColumnDesc[];
    pushRanking(existing?: Ranking): Ranking;
    takeSnapshot(col: Column): Ranking;
    insertRanking(r: Ranking, index?: number): void;
    protected triggerReorder(ranking: Ranking): void;
    removeRanking(ranking: Ranking): boolean;
    clearRankings(): void;
    getRankings(): Ranking[];
    getLastRanking(): Ranking;
    ensureOneRanking(): void;
    cleanUpRanking(_ranking: Ranking): void;
    abstract cloneRanking(existing?: Ranking): Ranking;
    push(ranking: Ranking, desc: IColumnDesc): Column | null;
    insert(ranking: Ranking, index: number, desc: IColumnDesc): Column | null;
    private nextId();
    protected abstract rankAccessor(row: IDataRow, id: string, desc: IColumnDesc, ranking: Ranking): number;
    private fixDesc(desc);
    create(desc: IColumnDesc): Column | null;
    clone(col: Column): Column;
    restoreColumn(dump: any): Column;
    find(idOrFilter: string | ((col: Column) => boolean)): Column | null;
    dump(): any;
    dumpColumn(col: Column): any;
    toDescRef(desc: any): any;
    fromDescRef(descRef: any): any;
    private createHelper;
    restoreRanking(dump: any): Ranking;
    restore(dump: any): void;
    abstract findDesc(ref: string): IColumnDesc | null;
    abstract deriveDefault(addSupporType?: boolean): Ranking;
    private deriveRanking(bundle);
    isAggregated(ranking: Ranking, group: IGroup): boolean;
    private unaggregateParents(ranking, group);
    setAggregated(ranking: Ranking, group: IGroup, value: boolean): void;
    aggregateAllOf(ranking: Ranking, aggregateAll: boolean): void;
    abstract sort(ranking: Ranking): Promise<IOrderedGroup[]> | IOrderedGroup[];
    abstract view(indices: number[]): Promise<any[]> | any[];
    abstract fetch(orders: number[][]): (Promise<IDataRow> | IDataRow)[][];
    abstract mappingSample(col: Column): Promise<number[]> | number[];
    abstract stats(indices: number[]): IStatsBuilder;
    isSelected(index: number): boolean;
    select(index: number): void;
    abstract searchAndJump(search: string | RegExp, col: Column): void;
    jumpToNearest(indices: number[]): void;
    selectAll(indices: number[]): void;
    selectAllOf(ranking: Ranking): void;
    setSelection(indices: number[]): void;
    toggleSelection(index: number, additional?: boolean): boolean;
    deselect(index: number): void;
    deselectAll(indices: number[]): void;
    selectedRows(): Promise<any[]> | any[];
    getSelection(): number[];
    clearSelection(): void;
    exportTable(ranking: Ranking, options?: Partial<IExportOptions>): Promise<string>;
}
export default ADataProvider;
