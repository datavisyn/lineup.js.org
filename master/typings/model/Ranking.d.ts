import AEventDispatcher from '../internal/AEventDispatcher';
import Column, { IColumnParent, IFlatColumn } from './Column';
import { IOrderedGroup } from './Group';
import { IDataRow, IGroup, IGroupData } from './interfaces';
export interface ISortCriteria {
    readonly col: Column;
    readonly asc: boolean;
}
export default class Ranking extends AEventDispatcher implements IColumnParent {
    id: string;
    private maxSortCriteria;
    private maxGroupColumns;
    static readonly EVENT_WIDTH_CHANGED: string;
    static readonly EVENT_FILTER_CHANGED: string;
    static readonly EVENT_LABEL_CHANGED: string;
    static readonly EVENT_ADD_COLUMN: string;
    static readonly EVENT_MOVE_COLUMN: string;
    static readonly EVENT_REMOVE_COLUMN: string;
    static readonly EVENT_DIRTY: string;
    static readonly EVENT_DIRTY_HEADER: string;
    static readonly EVENT_DIRTY_VALUES: string;
    static readonly EVENT_COLUMN_VISIBILITY_CHANGED: string;
    static readonly EVENT_SORT_CRITERIA_CHANGED: string;
    static readonly EVENT_GROUP_CRITERIA_CHANGED: string;
    static readonly EVENT_GROUP_SORT_CRITERIA_CHANGED: string;
    static readonly EVENT_DIRTY_ORDER: string;
    static readonly EVENT_ORDER_CHANGED: string;
    static readonly EVENT_GROUPS_CHANGED: string;
    private readonly sortCriteria;
    private readonly groupSortCriteria;
    private readonly groupColumns;
    private readonly columns;
    readonly comparator: (a: IDataRow, b: IDataRow) => number;
    readonly groupComparator: (a: IGroupData, b: IGroupData) => number;
    readonly grouper: (row: IDataRow) => IGroup;
    readonly dirtyOrder: () => void;
    private groups;
    constructor(id: string, maxSortCriteria?: number, maxGroupColumns?: number);
    protected createEventList(): string[];
    assignNewId(idGenerator: () => string): void;
    setOrder(order: number[]): void;
    setGroups(groups: IOrderedGroup[]): void;
    getOrder(): number[];
    getGroups(): IOrderedGroup[];
    dump(toDescRef: (desc: any) => any): any;
    restore(dump: any, factory: (dump: any) => Column | null): void;
    flatten(r: IFlatColumn[], offset: number, levelsToGo?: number, padding?: number): number;
    getPrimarySortCriteria(): ISortCriteria | null;
    getSortCriteria(): ISortCriteria[];
    getGroupSortCriteria(): ISortCriteria[];
    toggleSorting(col: Column): boolean;
    toggleGrouping(col: Column): boolean;
    getGroupCriteria(): Column[];
    setGroupCriteria(columns: Column[]): boolean;
    sortBy(col: Column | null, ascending?: boolean): boolean;
    groupBy(col: Column | null | Column[]): boolean;
    setSortCriteria(value: ISortCriteria | ISortCriteria[]): boolean;
    toggleGroupSorting(col: Column): boolean;
    groupSortBy(col: Column, asc: boolean): boolean;
    setMaxSortCriteria(maxSortCriteria: number): void;
    getMaxSortCriteria(): number;
    setMaxGroupColumns(maxGroupColumns: number): void;
    getMaxGroupColumns(): number;
    setGroupSortCriteria(value: ISortCriteria | ISortCriteria[]): boolean;
    private triggerResort(bak);
    readonly children: Column[];
    readonly length: number;
    insert(col: Column, index?: number): Column;
    move(col: Column, index?: number): Column | null;
    moveAfter(col: Column, reference: Column): Column | null;
    readonly fqpath: string;
    findByPath(fqpath: string): Column;
    indexOf(col: Column): number;
    at(index: number): Column;
    insertAfter(col: Column, ref: Column): Column | null;
    push(col: Column): Column;
    remove(col: Column): boolean;
    clear(): void;
    readonly flatColumns: Column[];
    find(idOrFilter: string | ((col: Column) => boolean)): Column | null;
    isFiltered(): boolean;
    filter(row: IDataRow): boolean;
    findMyRanker(): this;
    readonly fqid: string;
}
